package bchainlibs

import (
	"net"
	// "github.com/op/go-logging"
	"time"
	"strings"
	"crypto/sha256"
	"strconv"
	"encoding/hex"
)

// +++++++++ Constants
const (
	InternalTransactionType = iota
	InternalBlockType
	InternalQueryType

	TransactionType
	BlockType
	QueryType

	// Generated by the Blockchain layer, the idea is to remove the "stress" for the miner
	// to validate which is the last block and how to deal with it.
	// If we wanted to work TOTALLY separated, then this would not work, but for v1 it would.
	LastBlockType

	InternalPing
	InternalPong
)


const (
	RouterPort        = ":10000"
	LocalPort         = ":0"
	BlockCPort 	      = ":10001"
	MinerPort 	      = ":10002"
	Protocol          = "udp"
	BroadcastAddr     = "255.255.255.255"
	LocalhostAddr     = "127.0.0.1"
	NullhostAddr	  = "1.2.3.4"
)


// +++++++++ Packet structure
type Packet struct {
	// Header
	ID			 string     `json:"id"`
	Type         int        `json:"tp"`
	Source       net.IP     `json:"src"`
	Destination  net.IP     `json:"dst,omitempty"`
	Timestamp    int64      `json:"tms,omitempty"`
	Checksum     string     `json:"cks,omitempty"`

	// Body
	Query        *Query     `json:"qry,omitempty"`
	Block    	 *Block 	`json:"blk,omitempty"`
	Transaction  *Transaction 	`json:"trn,omitempty"`
}

type Query struct {
	// Header
	ID		  string     `json:"q_id"`
	// Body
	Function  string     `json:"q_f,omitempty"`
}

type Transaction struct {
	// Header
	ID		    string  `json:"t_id"`
	// Body
	Data    	*TransactionData `json:"t_d,omitempty"`
}

type TransactionData struct {
	Data	    string  `json:"d_dt,omitempty"`

	PacketID    string	`json:"d_id,omitempty"`
	Protocol    string	`json:"d_prt,omitempty"`
	Checksum    string	`json:"d_cks,omitempty"`
	Source      net.IP	`json:"d_src,omitempty"`
	Destination net.IP	`json:"d_dst,omitempty"`
	ActualHop   net.IP	`json:"d_hop,omitempty"`
	PreviousHop net.IP	`json:"d_php,omitempty"`
	Timestamp   int64   `json:"d_tst,omitempty"`
}

type Block struct {
	// Header
	ID    		string	`json:"b_id"` // ID = sha251^2( Nonce + PreviousID + MerkleTreeRoot)

	Nonce      		string	`json:"b_nnc,omitempty"`
	PreviousID 		string	`json:"b_pid,omitempty"` // This might be empty all the times
	MerkleTreeRoot  string	`json:"b_mtr"`

	// Body
	Transactions    []TransactionData   `json:"b_ts,omitempty"`
}

func BuildBlock(payload Packet, prid string, salt string, puzzle string, me net.IP) Packet {
	payload.Type = InternalBlockType

	sum := sha256.Sum256([]byte( puzzle ))
	sha256Hash := hex.EncodeToString(sum[:])

	payload.Block.ID = sha256Hash
	payload.Block.Nonce = salt
	payload.Block.PreviousID = prid

	return payload
}

func BuildTransaction(me net.IP, function string) Packet {

	layout := "01/02/2006 3:04:05 PM"
	t, _ := time.Parse(layout, "09/15/2017 1:44:05 PM")

	data := TransactionData{
				Data: function,

				PacketID: "123abc",
				Protocol: "UDP",
				Checksum: "303030dd7735b16f6399ecfa5aa9f0871b2b7d0db339df34da923bf2e7bb68b0",
				Source: net.ParseIP("10.12.0.5"),
				Destination: net.ParseIP("10.12.0.20"),
				//ActualHop: packet.Block.ActualHop,
				//PreviousHop: packet.Block.PreviousHop,
				Timestamp: t.UnixNano(),
		}

	transaction := Transaction{
		ID: "1",
		Data: &data,
	}

	payload := Packet{
		ID: generatePacketId(me),
		Type: InternalTransactionType,
		Source: me,
		Timestamp: time.Now().UnixNano(),
		Transaction: &transaction,
	}

	return payload
}

func BuildQuery(me net.IP, function string) Packet {

	query := Query{
				Function: function,
			}

	payload := Packet{
		ID: generatePacketId(me),
		Type: InternalQueryType,
		Source: me,
		Timestamp: time.Now().UnixNano(),
		Query: &query,
	}

	return payload
}

func BuildPing(me net.IP ) Packet {
	return buildInternal(me, InternalPing)
}

func BuildPong(me net.IP ) Packet {
	return buildInternal(me, InternalPong)
}

func buildInternal(me net.IP, pingType int ) Packet {

	payload := Packet{
		ID: generatePacketId(me),
		Type: pingType,
		Source: me,
	}

	return payload
}



func generatePacketId(me net.IP) string {
	// return me.String() + "_" + strconv.FormatInt(now, 10)

	dot := strings.LastIndex( me.String(), "." )
	ip := me.String()[dot+1:]

	now := time.Now().UnixNano()
	return ip + "_" + strconv.FormatInt(now, 10)
}

func (packet Packet) IsValid( piece string ) bool {
	valid := false

	puzzle := packet.Block.PreviousID + packet.Block.Nonce + packet.Block.MerkleTreeRoot

	checksum := CalculateSHA(puzzle)

	if strings.Contains(checksum, piece) {
		if checksum == packet.Block.ID {
			valid = true
		}
	}

	return valid
}



func (packet Packet) String() string {

	typeStr := "None"
	data := "-"
	switch packet.Type {

	case QueryType:
		typeStr = "Query"
		data = "( " + packet.Query.ID + ", " + packet.Query.Function + " )"
	break

	case TransactionType:
		typeStr = "Transaction"
		data = "( " + packet.Block.ID + ", " + packet.Block.Nonce + " )"
		break

	case BlockType:
		typeStr = "Block"
		data = "( " + packet.Block.ID + ", " + packet.Block.Nonce + " )"
	break
	}

	val := "-> ( ID: " + packet.ID + ", Type: " + typeStr + ", Source" + packet.Source.String() + " ) \n"

	val += " | "
	val += data

	return val
}
