package bchainlibs

import (
	"net"
	// "github.com/op/go-logging"
	"time"
)




// +++++++++ Constants
const (
	InternalUBlockType = iota // 0
	InternalVBlockType

	UBlockType
	VBlockType

	// Generated by the Blockchain layer, the idea is to remove the "stress" for the miner
	// to validate which is the last block and how to deal with it.
	// If we wanted to work TOTALLY separated, then this would not work, but for v1 it would.
	LastBlockType
	QueryType
)


const (
	RouterPort        = ":10000"
	LocalPort         = ":0"
	BlockCPort 	      = ":10001"
	MinerPort 	      = ":10002"
	Protocol          = "udp"
	BroadcastAddr     = "255.255.255.255"
	LocalhostAddr     = "127.0.0.1"
)


// +++++++++ Packet structure
type Packet struct {
	TID          string     `json:"tid"` // Timed ID ... created time + ip
	Type         int        `json:"tp"`

	Source       net.IP     `json:"src,omitempty"`
	//Destination  net.IP     `json:"dst,omitempty"`

	PrID       string	`json:"prd,omitempty"` // Previous block ID
	Salt       string	`json:"slt,omitempty"` // Salt value
	BID        string	`json:"bid,omitempty"` // Block ID = hash(previous block ID + Timed ID + salt)

	Query        *Query     `json:"qry,omitempty"`
	Block    	 *Block 	`json:"blck,omitempty"`
}

type Query struct {
	Function  string    `json:"fct,omitempty"`
}

type Block struct {
	Value      float32	`json:"otc,omitempty"`
	Function   string	`json:"bfct,omitempty"`
	Created    string   `json:"cts,omitempty"`
	Verified   string   `json:"vts,omitempty"`
	Verifier   net.IP   `json:"vrfr,omitempty"`
}

func AssembleVerifiedBlock(payload Packet, prid string, salt string, puzzle string, me net.IP) Packet {
	payload.Type = InternalVBlockType

	payload.PrID = prid
	payload.Salt = salt
	payload.BID = puzzle
	payload.Block.Verified = string(time.Now().UnixNano())
	payload.Block.Verifier = me

	return payload
}

//
//func AssembleAggregate(dest net.IP, out float32, obs int, dad net.IP, me net.IP, tmo int, stamp string, port int) Packet {
//	aggregate := Aggregate{
//		Outcome: out,
//		Observations: obs,
//	}
//
//	payload := Packet{
//		Type: AggregateType,
//		Parent: dad,
//		Source: me,
//		Destination: dest,
//		Port: port,
//		Timeout: tmo,
//		Timestamp: stamp,
//		Aggregate: &aggregate,
//	}
//
//	return payload
//}
//
//func AssembleQuery(payloadIn Packet, dad net.IP, me net.IP) Packet {
//	relaySet := []*net.IP{}
//	if payloadIn.Type != StartType {
//		relaySet = calculateRelaySet(payloadIn.Source, payloadIn.Query.RelaySet)
//	}
//
//	query := Query{
//		Function: payloadIn.Query.Function,
//		RelaySet: relaySet,
//	}
//
//	payload := Packet{
//		Type: QueryType,
//		Parent: dad,
//		Source: me,
//		Port: payloadIn.Port,
//		Timeout: payloadIn.Timeout,
//		Level: payloadIn.Level+1,
//		Query: &query,
//	}
//
//	return payload
//}
//
//
//func AssembleRoute(gw net.IP, payloadIn Packet) Packet {
//	payload := payloadIn
//
//	payload.Type = RouteByGossipType
//	payload.Gateway = gw
//	// payload.TimeToLive = payloadIn.TimeToLive-1
//	payload.Hops = payloadIn.Hops+1
//
//	return payload
//}