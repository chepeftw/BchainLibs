package bchainlibs

import (
	"net"
	"time"
	"strings"
	"strconv"
)

// +++++++++ Constants
const (
	InternalTransactionType = iota
	InternalBlockType
	InternalQueryType

	TransactionType
	BlockType
	QueryType

	// Generated by the Blockchain layer, the idea is to remove the "stress" for the miner
	// to validate which is the last block and how to deal with it.
	// If we wanted to work TOTALLY separated, then this would not work, but for v1 it would.
	LastBlockType

	LaunchElection
	//ResultFromElection

	InternalPing
	InternalPong

	// Raft Types
	RaftStart
	RaftResult
	RaftStop

	RequestForVote
	Vote
	RaftTimeout
	EndElection
	LeaderPing
)

const (
	RouterPort     = ":10000"
	LocalPort      = ":0"
	BlockchainPort = ":10001"
	MinerPort      = ":10002"
	RaftPort       = ":10005"
	Protocol       = "udp"
	BroadcastAddr  = "255.255.255.255"
	LocalhostAddr  = "127.0.0.1"
	NullhostAddr   = "1.2.3.4"
)

// +++++++++ Packet structure
type Packet struct {
	// Header
	ID          string `json:"id"`
	Type        int    `json:"tp"`
	Source      net.IP `json:"src"`
	Destination net.IP `json:"dst,omitempty"`
	Timestamp   int64  `json:"tms,omitempty"`
	Checksum    string `json:"cks,omitempty"`

	// Raft
	Action       int    `json:"r_act,omitempty"`
	Vote         string `json:"r_vot,omitempty"`
	Message      string `json:"r_msg,omitempty"`
	ElectionTime int64  `json:"r_elcTm,omitempty"`

	// Body
	Query       *Query       `json:"qry,omitempty"`
	Block       *Block       `json:"blk,omitempty"`
	Transaction *Transaction `json:"trns,omitempty"`
}

type Query struct {
	ID             string          `json:"q_id"`
	NumberLimit    int             `json:"q_nl"`
	TimeLimit      int64           `json:"q_tl"`
	Hops           int             `json:"q_hps,omitempty"`
	Created        int64           `json:"q_crt,omitempty"`
	GlobalProperty *GlobalProperty `json:"q_gp,omitempty"`
}

type GlobalProperty struct {
	Context     string `json:"gp_ct,omitempty"`
	Consequence string `json:"gp_cq,omitempty"`
	Operation   string `json:"gp_op,omitempty"`

	LocalProperties []LocalProperty `json:"gp_lps,omitempty"`
}

type LocalProperty struct {
	Context     string `json:"lp_ct,omitempty"`
	Consequence string `json:"lp_cq,omitempty"`
	Operation   string `json:"lp_op,omitempty"`
}

type Block struct {
	// Header
	ID string `json:"b_id"` // ID = sha251^2( Nonce + PreviousID + MerkleTreeRoot + QueryID)

	Nonce      string `json:"b_nnc,omitempty"`
	PreviousID string `json:"b_pid,omitempty"` // This might be empty all the times
	//MerkleTreeRoot string `json:"b_mtr"`
	Timestamp int64  `json:"b_tms,omitempty"`
	QueryID   string `json:"b_qrid"`

	// Body
	//Transactions []Transaction `json:"b_ts,omitempty"`
}

type Transaction struct {
	Data    string `json:"t_dt,omitempty"`
	QueryID string `json:"t_qid,omitempty"`

	Order       int    `json:"t_ord,omitempty"`
	PacketID    string `json:"t_id,omitempty"`
	Protocol    string `json:"t_prt,omitempty"`
	Checksum    string `json:"t_cks,omitempty"`
	Source      net.IP `json:"t_src,omitempty"`
	Destination net.IP `json:"t_dst,omitempty"`
	ActualHop   net.IP `json:"t_hop,omitempty"`
	PreviousHop net.IP `json:"t_php,omitempty"`
	Timestamp   int64  `json:"t_tst,omitempty"`
}

//type ByOrder []TransactionData
//type ByTimestamp []TransactionData
//
//func (a ByOrder) Len() int           { return len(a) }
//func (a ByOrder) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
//func (a ByOrder) Less(i, j int) bool { return a[i].Order < a[j].Order }
//
//func (a ByTimestamp) Len() int           { return len(a) }
//func (a ByTimestamp) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
//func (a ByTimestamp) Less(i, j int) bool { return a[i].Timestamp < a[j].Timestamp }

func CreateRaftResultPacket(me net.IP) Packet {
	payload := Packet{
		ID:        generatePacketId(me),
		Type:      RaftResult,
		Source:    me,
		Timestamp: time.Now().UnixNano(),
	}

	return payload
}

// For the Miner
func CreateLaunchElectionPacket(me net.IP, query Query) Packet {
	block := Block{
		QueryID: query.ID,
	}

	payload := Packet{
		ID:        generatePacketId(me),
		Type:      LaunchElection,
		Source:    me,
		Timestamp: time.Now().UnixNano(),

		Block: &block,
	}

	return payload
}

// For raft
func CreateRaftStartPacket(me net.IP) Packet {
	return createRaftGenPacket(me, RaftStart)
}

func CreateRaftStopPacket(me net.IP) Packet {
	return createRaftGenPacket(me, RaftStop)
}

func createRaftGenPacket(me net.IP, raftType int) Packet {
	payload := Packet{
		ID:        generatePacketId(me),
		Type:      raftType,
		Source:    net.ParseIP("0.0.0.0"),
		Timestamp: time.Now().UnixNano(),
	}

	return payload
}

func CreateBlockPacket(me net.IP, block Block) Packet {
	payload := Packet{
		ID:        generatePacketId(me),
		Type:      InternalBlockType,
		Source:    me,
		Timestamp: time.Now().UnixNano(),
		Block:     &block,
	}

	return payload
}

func CreateTransaction(me net.IP) Packet {

	layout := "01/02/2006 3:04:05 PM"
	t, _ := time.Parse(layout, "09/15/2017 1:44:05 PM")

	transaction := Transaction{
		Data:    "function",
		QueryID: "1",

		PacketID: "123abc",
		Protocol: "UDP",
		//Checksum:    "303030dd7735b16f6399ecfa5aa9f0871b2b7d0db339df34da923bf2e7bb68b0",
		Source:      net.ParseIP("10.12.0.5"),
		Destination: net.ParseIP("10.12.0.20"),
		//ActualHop: packet.Block.ActualHop,
		//PreviousHop: packet.Block.PreviousHop,
		Timestamp: t.UnixNano(),
	}

	payload := Packet{
		ID:          generatePacketId(me),
		Type:        InternalTransactionType,
		Source:      me,
		Timestamp:   time.Now().UnixNano(),
		Transaction: &transaction,
	}

	return payload
}

func CreateQuery(me net.IP) Packet {

	globalProperty := GlobalProperty{
		Context:         "Context",
		Consequence:     "Consequence",
		Operation:       "",
		LocalProperties: nil,
	}

	query := Query{
		GlobalProperty: &globalProperty,
		ID:             strconv.FormatInt(time.Now().Unix(), 10),
		NumberLimit:    4,
		TimeLimit:      600000000,
		Hops:           0,
		Created:        time.Now().Unix(),
	}

	payload := Packet{
		ID:        generatePacketId(me),
		Type:      InternalQueryType,
		Source:    me,
		Timestamp: time.Now().UnixNano(),
		Query:     &query,
	}

	return payload
}

func BuildPing(me net.IP) Packet {
	return buildInternal(me, InternalPing)
}

func BuildPong(me net.IP) Packet {
	return buildInternal(me, InternalPong)
}

func buildInternal(me net.IP, pingType int) Packet {

	payload := Packet{
		ID:     generatePacketId(me),
		Type:   pingType,
		Source: me,
	}

	return payload
}

func generatePacketId(me net.IP) string {
	// return me.String() + "_" + strconv.FormatInt(now, 10)

	dot := strings.LastIndex(me.String(), ".")
	ip := me.String()[dot+1:]

	now := time.Now().UnixNano()
	return ip + "_" + strconv.FormatInt(now, 10)
}

func (packet Packet) IsValid(piece string) bool {
	valid := false

	//puzzle := packet.Block.PreviousID + packet.Block.Nonce + packet.Block.MerkleTreeRoot
	puzzle := packet.Block.PreviousID + packet.Block.Nonce

	checksum := MyCalculateSHA(puzzle)

	if strings.Contains(checksum, piece) {
		if checksum == packet.Block.ID {
			valid = true
		}
	}

	return valid
}

func (packet Packet) String() string {

	typeStr := "None"
	data := "-"
	switch packet.Type {

	case QueryType:
		typeStr = "Query"
		data = "{ " + packet.Query.GlobalProperty.Context + " } --> { " + packet.Query.GlobalProperty.Consequence + " }"
		break

	case TransactionType:
		typeStr = "Transaction"
		data = "( " + packet.Transaction.Data + ", " + packet.Transaction.PacketID + ", " + packet.Transaction.Checksum + " )"
		break

	case BlockType:
		typeStr = "Block"
		data = "( " + packet.Block.ID + ", " + packet.Block.Nonce + " )"
		break
	}

	val := "-> ( ID: " + packet.ID + ", Type: " + typeStr + ", Source" + packet.Source.String() + " ) \n"
	val += " | "
	val += data

	return val
}

func (block Block) String() string {
	val := "-> ( "
	val += "ID: " + block.ID
	val += ", "
	val += "Nonce: " + block.Nonce
	val += ", "
	val += "PreviousID: " + block.PreviousID
	val += ", "
	//val += "     MerkleTreeRoot: " + block.MerkleTreeRoot + ", "
	val += "Timestamp: " + strconv.Itoa(int(block.Timestamp))
	val += ", "
	val += "QueryID: " + block.QueryID
	//val += "Number of transactions: " + strconv.Itoa(len(block.Transactions)) + " ) \n"
	val += " )"

	return val
}

func (data Transaction) String() string {
	val := ""

	val += strconv.Itoa(data.Order) + ", "
	val += data.PacketID + ", "
	val += data.Protocol + ", "
	val += data.Checksum + ", "
	val += data.Source.String() + ", "
	val += data.Destination.String() + ", "
	val += data.ActualHop.String() + ", "
	val += strconv.FormatInt(data.Timestamp, 10)

	return val
}
